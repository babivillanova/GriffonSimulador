<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>Griffon Living | Simulador</title>
		<!-- <link rel="shortcut icon" href="../../files/favicon.ico" /> -->
		<link rel="stylesheet" type="text/css" href="Babi.css" />
		<script src="https://cdn.rawgit.com/Keyang/node-csvtojson/d41f44aa/browser/csvtojson.min.js"></script>
	</head>
	<body>
		<div class="head">
			<div>
				<!-- <div id="titulo">Griffon Living</div> -->
				<img
					id="titulo"
					onclick="window.open('http://www.griffonliving.com', '_blank')"
					src="https://cdn.lugc.link/2236a0e0-de23-45c6-8206-6f3b7c7e25a4/-/preview/-/stretch/off/-/format/auto/-/quality/normal/-/resize/150x/"
				/>
			</div>
			<div id="direita">
				<main id="preco">R$ 800</main>
				<div id="subtitulo">
					1️⃣Inclinação
					<select name="inclinacao" id="inclinacao" form="inclinacao">
						<option value="Plano" >Plano</option>
						<option value="Declive">Declive</option>
						<option value="Aclive" selected>Aclive</option>
					</select>
				</div>
				<div id="subtitulo">
					2️⃣Carbon
					<select name="modelo" id="modelo" form="modelo">
						<!-- <option value="2S+Q">2S+Q</option> -->
						<option value="3S" >3S</option>
						<option value="3S+Q" selected>3S+Q</option>
						<option value="4S">4S</option>
						<option value="4S+Q">4S+Q</option>
					</select>
				</div>
			</div>
		</div>

		
		<div id="menu">
			<h2>3️⃣Parâmetros</h2>
		<div id="container">
			<div class="label">
				<label for="inA">Desnível do terreno</label>
				<label for="inC">Altura da calçada até a casa</label>
				<label for="inD">Recuo frontal</label>
				<label for="inE">Recuo lateral</label>
				<label for="inB">Profundidade do terreno</label>
				<!-- <button id="clip">Esconder cobertura</button> -->
				<button id="cube">Adicionar Piscina</button>
			</div>
			<div class="input">
				<form>
					<div id="slider" tag="slider">
						<input
							class="bar"
							type="range"
							id="inA"
							min="2.5"
							max="10"
							value="6"
							step="0.5"
							onchange="outA.value=value"
						/>
						<span class="highlight"></span>
						<output id="outA" >6</output>
					</div>
				</form>

				<form>
					<div id="slider" tag="slider">
						<input
							class="bar"
							type="range"
							id="inC"
							min="2.5"
							max="7"
							value="3.5"
							step="0.1"
							onchange="outC.value=value"
						/>
						<span class="highlight"></span>
						<output id="outC">3.5</output>
					</div>
				</form>
				<form>
					<div id="slider" tag="slider">
						<input
							class="bar"
							type="range"
							id="inD"
							min="2"
							max="7"
							value="5"
							step="0.5"
							onchange="outD.value=value"
						/>
						<span class="highlight"></span>
						<output id="outD">5</output>
					</div>
				</form>
				<form>
					<div id="slider" tag="slider">
						<input
							class="bar"
							type="range"
							id="inE"
							min="1.5"
							max="4"
							value="1.5"
							step="0.5"
							onchange="outE.value=value"
						/>
						<span class="highlight"></span>
						<output id="outE">1.5</output>
					</div>
				</form>
				<form>
					<div id="slider" tag="slider">
						<input
							class="bar"
							type="range"
							id="inB"
							min="32"
							max="45"
							value="37"
							step="0.1"
							onchange="outB.value=value"
						/>
						<span class="highlight"></span>
						<output id="outB">37</output>
					</div>
				</form>
				<div style="font-size: 10px; line-height: 10px">
					Aqui a piscina vai ter </br>um slider pra andar
				</div>
			</div>
		</div>
		<div id="containerPlano">
			<div class="label">
				
				
				<label for="inG">Recuo frontal</label>
				<label for="inH">Recuo lateral</label>
				<label for="inI">Profundidade do terreno</label>
				<label for="inF">Largura do terreno</label>
				<!-- <button id="clip">Esconder cobertura</button> -->
				<button id="cube2">Adicionar Piscina</button>
			</div>
			<div class="input">
				
				<form>
					<div id="slider" tag="slider">
						<input
							class="bar"
							type="range"
							id="inG"
							min="2"
							max="7"
							value="5"
							step="0.5"
							onchange="outG.value=value"
						/>
						<span class="highlight"></span>
						<output id="outG">5</output>
					</div>
				</form>
				<form>
					<div id="slider" tag="slider">
						<input
							class="bar"
							type="range"
							id="inH"
							min="0.5"
							max="6"
							value="0.5"
							step="0.1"
							onchange="outH.value=value"
						/>
						<span class="highlight"></span>
						<output id="outH">0.5</output>
					</div>
				</form>
				<form>
					<div id="slider" tag="slider">
						<input
							class="bar"
							type="range"
							id="inI"
							min="32"
							max="45"
							value="37"
							step="0.1"
							onchange="outI.value=value"
						/>
						<span class="highlight"></span>
						<output id="outI">37</output>
					</div>
				</form>
				<form>
					<div id="slider" tag="slider">
						<input 
						disabled

							class="bar"
							type="range"
							id="inF"
							min="12"
							max="23"
							value="12"
							step="0.1"
													/>
						<span class="highlight"></span>
						<output id="outF" >12</output>
					</div>
				</form>
				<div style="font-size: 10px; line-height: 10px">
					Aqui a piscina vai ter </br>um slider pra andar
				</div>
			</div>
		</div>
		<div id="containerDeclive">
			<div class="label">
				<label for="inJ">Desnível do terreno</label>
				<label for="inK">Altura da casa até a calçada</label>
				<label for="inL">Recuo frontal</label>
				<label for="inM">Recuo lateral</label>
				<label for="inN">Profundidade do terreno</label>
				<label for="inO">Profundidade do quintal</label>
				<!-- <button id="clip">Esconder cobertura</button> -->
				<button id="cube3">Adicionar Piscina</button>
			</div>
			<div class="input">
				<form>
					<div id="slider" tag="slider">
						<input
							class="bar"
							type="range"
							id="inJ"
							min="2.5"
							max="10"
							value="6"
							step="0.5"
							onchange="outJ.value=value"
						/>
						<span class="highlight"></span>
						<output id="outJ" >6</output>
					</div>
				</form>

				<form>
					<div id="slider" tag="slider">
						<input
							class="bar"
							type="range"
							id="inK"
							min="0"
							max="1.5"
							value="0"
							step="0.1"
							onchange="outK.value=value"
						/>
						<span class="highlight"></span>
						<output id="outK">0</output>
					</div>
				</form>
				<form>
					<div id="slider" tag="slider">
						<input
							class="bar"
							type="range"
							id="inL"
							min="2"
							max="7"
							value="5"
							step="0.5"
							onchange="outL.value=value"
						/>
						<span class="highlight"></span>
						<output id="outL">5</output>
					</div>
				</form>
				<form>
					<div id="slider" tag="slider">
						<input
							class="bar"
							type="range"
							id="inM"
							min="0.5"
							max="4"
							value="1.5"
							step="0.5"
							onchange="outM.value=value"
						/>
						<span class="highlight"></span>
						<output id="outM">1.5</output>
					</div>
				</form>
				<form>
					<div id="slider" tag="slider">
						<input
							class="bar"
							type="range"
							id="inN"
							min="32"
							max="45"
							value="37"
							step="0.1"
							onchange="outN.value=value"
						/>
						<span class="highlight"></span>
						<output id="outN">37</output>
					</div>
				</form>
				<form>
					<div id="slider" tag="slider">
						<input
							class="bar"
							type="range"
							id="inO"
							min="20"
							max="25"
							value="20"
							step="0.1"
							onchange="outO.value=value"
						/>
						<span class="highlight"></span>
						<output id="outO">20</output>
					</div>
				</form>
				<div style="font-size: 10px; line-height: 10px">
					Aqui a piscina vai ter </br>um slider pra andar
				</div>
			</div>
		</div>
		<div id="containerGeral">
			<button id="edicula">Adicionar Edícula</button>
			<button id="telhado">Retirar telhado</button>
		</div>
	</div>
		<script
			async
			src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"
		></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "../examples/jsm/"
				}
			}
		</script>
		<script type="x-shader/x-fragment" id="PCSS">

			#define LIGHT_WORLD_SIZE 0.005
			#define LIGHT_FRUSTUM_WIDTH 3.75
			#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)
			#define NEAR_PLANE 9.5

			#define NUM_SAMPLES 17
			#define NUM_RINGS 11
			#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES

			vec2 poissonDisk[NUM_SAMPLES];

			void initPoissonSamples( const in vec2 randomSeed ) {
				float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );
				float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );

				// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
				float angle = rand( randomSeed ) * PI2;
				float radius = INV_NUM_SAMPLES;
				float radiusStep = radius;

				for( int i = 0; i < NUM_SAMPLES; i ++ ) {
					poissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );
					radius += radiusStep;
					angle += ANGLE_STEP;
				}
			}

			float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation
				return (zReceiver - zBlocker) / zBlocker;
			}

			float findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {
				// This uses similar triangles to compute what
				// area of the shadow map we should search
				float searchRadius = LIGHT_SIZE_UV * ( zReceiver - NEAR_PLANE ) / zReceiver;
				float blockerDepthSum = 0.0;
				int numBlockers = 0;

				for( int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++ ) {
					float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));
					if ( shadowMapDepth < zReceiver ) {
						blockerDepthSum += shadowMapDepth;
						numBlockers ++;
					}
				}

				if( numBlockers == 0 ) return -1.0;

				return blockerDepthSum / float( numBlockers );
			}

			float PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {
				float sum = 0.0;
				float depth;
				#pragma unroll_loop_start
				for( int i = 0; i < 17; i ++ ) {
					depth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );
					if( zReceiver <= depth ) sum += 1.0;
				}
				#pragma unroll_loop_end
				#pragma unroll_loop_start
				for( int i = 0; i < 17; i ++ ) {
					depth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );
					if( zReceiver <= depth ) sum += 1.0;
				}
				#pragma unroll_loop_end
				return sum / ( 2.0 * float( 17 ) );
			}

			float PCSS ( sampler2D shadowMap, vec4 coords ) {
				vec2 uv = coords.xy;
				float zReceiver = coords.z; // Assumed to be eye-space z in this code

				initPoissonSamples( uv );
				// STEP 1: blocker search
				float avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver );

				//There are no occluders so early out (this saves filtering)
				if( avgBlockerDepth == -1.0 ) return 1.0;

				// STEP 2: penumbra size
				float penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );
				float filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;

				// STEP 3: filtering
				//return avgBlockerDepth;
				return PCF_Filter( shadowMap, uv, zReceiver, filterRadius );
			}
		</script>
		<script type="x-shader/x-fragment" id="PCSSGetShadow">

			return PCSS( shadowMap, shadowCoord );
		</script>

		<script type="module">
			import * as THREE from "three";
			import Stats from "./jsm/libs/stats.module.js";
			

			import {
				BoxGeometry,
				BufferGeometry,
				CircleGeometry,
				Color,
				ConeGeometry,
				Curve,
				CylinderGeometry,
				DodecahedronGeometry,
				DoubleSide,
				ExtrudeGeometry,
				Float32BufferAttribute,
				Group,
				IcosahedronGeometry,
				LatheGeometry,
				LineSegments,
				LineBasicMaterial,
				Mesh,
				MeshPhongMaterial,
				OctahedronGeometry,
				PerspectiveCamera,
				PlaneGeometry,
				PlaneBufferGeometry,
				PointLight,
				RingGeometry,
				Scene,
				Shape,
				ShapeGeometry,
				SphereGeometry,
				TetrahedronGeometry,
				TorusGeometry,
				TorusKnotGeometry,
				TubeGeometry,
				Vector2,
				Vector3,
				WireframeGeometry,
				WebGLRenderer,
				BufferAttribute,
				TextureLoader,
				RepeatWrapping,
			} from "three";

			import { OrbitControls } from "three/addons/controls/OrbitControls.js";

			import { IFCLoader } from "three/addons/loaders/IFCLoader.js";

			import { Water } from './jsm/objects/Water2.js';

			let mesh,
				model,
				IFCModel,
				CASA,
				lightHelper,
				shadowCameraHelper,
				localPlane, ediculaGeo, ediculaMesh, water; //modelo da casa
			let camera, scene, renderer, geometry, orbit, all;
			let geometries = [];
			let verticesS = [];
			let geometries2 = [];
			let verticesS2 = [];
			let meshs2 = [];

			let meshs = [];
			//create new Vector3 named modelPosition
			let modelA = 0;
			let modelB = 0;
			let modelC = 0;

			let alturaCasa = 3.5; //tem slider
			let alturaCasaDeclive = 0; //tem slider
			let desnivelTerreno = 6 - alturaCasa; //tem slider
			let recuoFrontal = 5;
			let profundidadeTerreno = 37 - recuoFrontal;
			let recuoLateral = 1;
			let fundodaCasa = profundidadeTerreno - 2;
			let larguraMorro = 3.7;
			let larguraFrente = 7.3;
			let larguraCasaPlana = 11;
			let profundidadeQuintal = 20;
			let sizeS = [];
			let sizeS2 = [];
			
			function setSizeS() {
				sizeS = [
					[
						-recuoLateral,
						-alturaCasa,
						-recuoFrontal,
						-20,
						-alturaCasa,
						-recuoFrontal,
						-recuoLateral,
						desnivelTerreno,
						profundidadeTerreno,
					], //a, b d terreno vizinho esquerda
					[
						-20,
						desnivelTerreno,
						profundidadeTerreno,
						-20,
						-alturaCasa,
						-recuoFrontal,
						-recuoLateral,
						desnivelTerreno,
						profundidadeTerreno,
					], //terrreno vizinho
					[
						-recuoLateral,
						desnivelTerreno,
						profundidadeTerreno,
						-recuoLateral,
						-alturaCasa,
						-recuoFrontal,
						-recuoLateral,
						0,
						fundodaCasa,
					], //fechamento terreno vizinho
					[
						-recuoLateral,
						0,
						0,
						larguraMorro,
						0,
						0,
						-recuoLateral,
						-alturaCasa,
						-recuoFrontal,
					], //bdc morro
					[
						larguraMorro,
						0,
						0,
						-recuoLateral,
						-alturaCasa,
						-recuoFrontal,
						larguraMorro,
						-alturaCasa,
						-recuoFrontal,
					], //morro
					[0, 0, 0, -recuoLateral, 0, fundodaCasa, 0, 0, fundodaCasa],
					[0, 0, 0, -recuoLateral, 0, fundodaCasa, -recuoLateral, 0, 0],

					[
						-recuoLateral,
						0,
						0,
						-recuoLateral,
						-alturaCasa,
						-recuoFrontal,
						-recuoLateral,
						0,
						fundodaCasa,
					], //preenchimento lateral 1
					[
						larguraMorro,
						-2.5,
						0,

						larguraMorro,
						-alturaCasa,
						-recuoFrontal,
						larguraMorro,
						0,
						0,
					],
					[
						larguraMorro,
						-2.5,
						-1.4,
						larguraMorro,
						-alturaCasa,
						-recuoFrontal,
						larguraMorro + 2,
						-2.5,
						-1.4,
					],
					[
						larguraMorro + 2,
						-alturaCasa,
						-recuoFrontal,
						larguraMorro,
						-alturaCasa,
						-recuoFrontal,
						larguraMorro + 2,
						-2.5,
						-1.4,
					],
					[
						larguraMorro,
						-2.5,
						-1.4,
						larguraMorro,
						-alturaCasa,
						-recuoFrontal,
						larguraMorro + larguraFrente + recuoLateral,
						-2.5,
						-1.4,
					],
					[
						larguraMorro + larguraFrente + recuoLateral,
						-alturaCasa,
						-recuoFrontal,
						larguraMorro,
						-alturaCasa,
						-recuoFrontal,
						larguraMorro + larguraFrente + recuoLateral,
						-2.5,
						-1.4,
					],
					[
						larguraMorro + larguraFrente,
						-2.5,
						-1.4,
						larguraMorro + larguraFrente,
						-2.5,
						4.2,
						larguraMorro + larguraFrente + recuoLateral,
						-2.5,
						-1.4,
					],
					[
						larguraMorro + larguraFrente + recuoLateral,
						-2.5,
						4.2,
						larguraMorro + larguraFrente,
						-2.5,
						4.2,
						larguraMorro + larguraFrente + recuoLateral,
						-2.5,
						-1.4,
					],
					[
						larguraMorro + larguraFrente + recuoLateral,
						-2.5,
						4.2,
						larguraMorro + larguraFrente,
						-2.5,
						4.2,
						larguraMorro + larguraFrente,
						0,
						15,
					], //rampa
					[
						larguraMorro + larguraFrente + recuoLateral,
						-2.5,
						4.2,
						larguraMorro + larguraFrente + recuoLateral,
						0,
						15,
						larguraMorro + larguraFrente,
						0,
						15,
					], //rampa
					[
						larguraMorro + larguraFrente,
						0,
						fundodaCasa,
						larguraMorro + larguraFrente + recuoLateral,
						0,
						15,
						larguraMorro + larguraFrente,
						0,
						15,
					],
					[
						larguraMorro + larguraFrente,
						0,
						fundodaCasa,
						larguraMorro + larguraFrente + recuoLateral,
						0,
						fundodaCasa,
						larguraMorro + larguraFrente + recuoLateral,
						0,
						15,
					],
					[
						-recuoLateral,
						0,
						fundodaCasa,

						larguraMorro + 7.3 + recuoLateral,
						0,
						fundodaCasa,
						-recuoLateral,
						desnivelTerreno,
						profundidadeTerreno,
					],
					[
						larguraMorro + 7.3 + recuoLateral,
						desnivelTerreno,
						profundidadeTerreno,
						larguraMorro + 7.3 + recuoLateral,
						0,
						fundodaCasa,
						-recuoLateral,
						desnivelTerreno,
						profundidadeTerreno,
					],
					[
						larguraMorro + 7.3 + recuoLateral,
						-alturaCasa,
						-recuoFrontal,
						larguraMorro + 7.3 + recuoLateral + 20,
						-alturaCasa,
						-recuoFrontal,
						larguraMorro + 7.3 + recuoLateral,
						desnivelTerreno,
						profundidadeTerreno,
					], //a, b d terreno vizinho2
					[
						larguraMorro + 7.3 + recuoLateral + 20,
						desnivelTerreno,
						profundidadeTerreno,

						larguraMorro + 7.3 + recuoLateral + 20,
						-alturaCasa,
						-recuoFrontal,
						larguraMorro + 7.3 + recuoLateral,
						desnivelTerreno,
						profundidadeTerreno,
					], //terreno vizinho2
					[
						larguraMorro + 7.3 + recuoLateral,
						desnivelTerreno,
						profundidadeTerreno,
						larguraMorro + 7.3 + recuoLateral,
						-alturaCasa,
						-recuoFrontal,
						larguraMorro + 7.3 + recuoLateral,
						0,
						fundodaCasa,
					],
					[
						larguraMorro + 7.3 + recuoLateral,
						0,
						fundodaCasa,
						larguraMorro + 7.3 + recuoLateral,
						-2.5,
						4.2,

						larguraMorro + 7.3 + recuoLateral,
						0,
						15,
					], // fechamento lateral
					[
						larguraMorro + 7.3,
						0,
						fundodaCasa,
						larguraMorro + 7.3,
						-2.5,
						4.2,

						larguraMorro + 7.3,
						0,
						4.2,
					], // fechamento lateral embaixo da casa
					[
						larguraMorro + 7.3 + recuoLateral,
						-2.5,
						3,
						larguraMorro + 7.3 + recuoLateral,
						-2.5,
						-1.4,
						larguraMorro + 7.3 + recuoLateral,
						-alturaCasa,
						-recuoFrontal,
					],
					[0, 0, fundodaCasa, larguraMorro + 7.3, 0, fundodaCasa, 0, 0, 15],
					[
						larguraMorro + 7.3,
						0,
						fundodaCasa,
						0,
						0,
						15,
						larguraMorro + 7.3,
						0,
						15,
					], // plano do quintal
				];
			}
		

			function setSizeSPlano() {
				sizeS = [
				[
						-recuoLateral - 0.1,
						0,
						-recuoFrontal,
						-20,
						0,
						-recuoFrontal,
						-recuoLateral - 0.1,
						0,
						profundidadeTerreno,
					], //a, b d terreno vizinho esquerda
					[
						-20,
						0,
						profundidadeTerreno,
						-20,
						0,
						-recuoFrontal,
						-recuoLateral -0.1,
						0,
						profundidadeTerreno,
					], //terrreno vizinho
						[-recuoLateral,0, -recuoFrontal, -recuoLateral, 0, profundidadeTerreno, larguraCasaPlana + recuoLateral, 0, -recuoFrontal], //lote
						[ -recuoLateral, 0, profundidadeTerreno, larguraCasaPlana + recuoLateral, 0, -recuoFrontal, recuoLateral + larguraCasaPlana, 0, profundidadeTerreno]	, //lote
								[larguraCasaPlana + recuoLateral +0.1, 0, -recuoFrontal, larguraCasaPlana + recuoLateral + 0.1, 0, profundidadeTerreno, larguraCasaPlana + recuoLateral + 20, 0, profundidadeTerreno], //lote
							[larguraCasaPlana + recuoLateral + 20, 0, profundidadeTerreno, larguraCasaPlana + recuoLateral + 0.1, 0, -recuoFrontal, larguraCasaPlana + recuoLateral + 20, 0, -recuoFrontal], //lote
						]
			}

			function setSizeSDeclive() {
				
				sizeS = [
				[
						-recuoLateral ,
						+alturaCasaDeclive,
						-recuoFrontal,
						-20,
						+alturaCasaDeclive,
						-recuoFrontal,
						-recuoLateral ,
						-desnivelTerreno + alturaCasaDeclive, 
						profundidadeTerreno,	
					], //a, b d terreno vizinho direita
					[
						-20,
						-desnivelTerreno + alturaCasaDeclive,
						profundidadeTerreno,
						-20,+alturaCasaDeclive,-recuoFrontal,
						-recuoLateral ,-desnivelTerreno + alturaCasaDeclive ,profundidadeTerreno,
					], //terrreno vizinho direita2

					[-recuoLateral,+alturaCasaDeclive, -recuoFrontal,
					 -recuoLateral,0, 0, 
					 larguraCasaPlana + recuoLateral, +alturaCasaDeclive, -recuoFrontal], //ENTRADA 

					 [ -recuoLateral, 0, 0, 
					 larguraCasaPlana + recuoLateral, +alturaCasaDeclive, -recuoFrontal, 
					 recuoLateral + larguraCasaPlana, 0 , 0]	, //ENTRADA

						[-recuoLateral, -3, profundidadeQuintal,
						 -recuoLateral, -desnivelTerreno + alturaCasaDeclive, profundidadeTerreno, 
						 larguraCasaPlana + recuoLateral, -3, profundidadeQuintal], //lote

						[ -recuoLateral, -desnivelTerreno + alturaCasaDeclive, profundidadeTerreno, 
						larguraCasaPlana + recuoLateral, -3, profundidadeQuintal, 
						recuoLateral + larguraCasaPlana,-desnivelTerreno + alturaCasaDeclive , profundidadeTerreno]	, //lote
						
						[0, -3, profundidadeQuintal,
						0,0, profundidadeQuintal,
						larguraCasaPlana, -3, profundidadeQuintal
					], //fecha o quintal

					[0,0, profundidadeQuintal,
						larguraCasaPlana, -3, profundidadeQuintal,
						larguraCasaPlana, 0, profundidadeQuintal],

						[0, 0, profundidadeQuintal,
						  0, 0, 0, 
						  larguraCasaPlana , 0, profundidadeQuintal										 
						], //casa

						[  larguraCasaPlana , 0, profundidadeQuintal,
						  0, 0, 0,
						  larguraCasaPlana , 0, 0
						], //casa

						[larguraCasaPlana , 0, 0,
						larguraCasaPlana , 0, profundidadeQuintal,
						larguraCasaPlana, -3, profundidadeQuintal
					], //fechamento lateral casa
					[0 , 0, 0,
						0 , 0, profundidadeQuintal,
						0, -3, profundidadeQuintal],//fechamento lateral2 casa

						[0 , 0, 0,
						-recuoLateral, -3, profundidadeQuintal,
						0, -3, profundidadeQuintal],//rampa1.1

						[0,0,0,
						-recuoLateral, -3, profundidadeQuintal,
						-recuoLateral, 0, 0],//rampa1.2

						[larguraCasaPlana , 0, 0,
						larguraCasaPlana, -3, profundidadeQuintal,
						larguraCasaPlana + recuoLateral, -3, profundidadeQuintal],//rampa2.1

						[larguraCasaPlana , 0, 0,
						larguraCasaPlana + recuoLateral, 0, 0,
						larguraCasaPlana + recuoLateral, -3, profundidadeQuintal],//rampa2.2


						  [larguraCasaPlana + recuoLateral, +alturaCasaDeclive, 
						  -recuoFrontal, larguraCasaPlana + recuoLateral , -desnivelTerreno + alturaCasaDeclive, 
						  profundidadeTerreno, larguraCasaPlana + recuoLateral + 20, 
						  -desnivelTerreno + alturaCasaDeclive, profundidadeTerreno], //VIZINHO ESQUERDA

							[larguraCasaPlana + recuoLateral + 20, -desnivelTerreno + alturaCasaDeclive, 
							profundidadeTerreno, larguraCasaPlana + recuoLateral , +alturaCasaDeclive,
							 -recuoFrontal, larguraCasaPlana + recuoLateral + 20, +alturaCasaDeclive, -recuoFrontal], //VIZINHO ESQUERDA2

							[ -recuoLateral ,
						+alturaCasaDeclive,
						-recuoFrontal,
						-recuoLateral, -3, profundidadeQuintal,
						-recuoLateral ,
						-desnivelTerreno + alturaCasaDeclive, 
						profundidadeTerreno,	
			], // fechamento vizinho direita

			[ larguraCasaPlana + recuoLateral ,
						+alturaCasaDeclive,
						-recuoFrontal,
						larguraCasaPlana + recuoLateral , -3, profundidadeQuintal,
						larguraCasaPlana + recuoLateral  ,
						-desnivelTerreno + alturaCasaDeclive, 
						profundidadeTerreno,	],//fechamento vizinho esquerda

						[ -recuoLateral ,
						+alturaCasaDeclive,
						-recuoFrontal,
						-recuoLateral, -3, profundidadeQuintal,
						-recuoLateral ,
						0, 
						0
			], // fechamento vizinho direita
			
			[ larguraCasaPlana + recuoLateral ,
						+alturaCasaDeclive,
						-recuoFrontal,
						larguraCasaPlana + recuoLateral , -3, profundidadeQuintal,
						larguraCasaPlana + recuoLateral  ,
						0, 
						0	],//fechamento vizinho esquerda
							]
			}
			

			
			const textureLoader = new THREE.TextureLoader();
			const gColor = textureLoader.load('textures/Grass/Grass_004_SD/Grass_004_COLOR.jpg');
			const gNormal = textureLoader.load('textures/Grass/Grass_004_SD/Grass_004_NORM.jpg');
			const gRough = textureLoader.load('textures/Grass/Grass_004_SD/Grass_004_ROUGH.jpg');
			const gAmbient = textureLoader.load('textures/Grass/Grass_004_SD/Grass_004_OCC.jpg');
			const gDisp = textureLoader.load('textures/Grass/Grass_004_SD/Grass_004_DISP.png');


			// const material = new MeshPhongMaterial({
			// 	map: gramatexture,
			// 	roughness: 0.5,
			// 	// color: "#39542e",
			// 	flatShading: true,
			// 	side: DoubleSide,
			// });


			const material = new THREE.MeshPhongMaterial({
				color: "#39542e",
				flatShading: true,
				side: DoubleSide,
			});


			

			const material2 = new MeshPhongMaterial({
				color: "gray",
				flatShading: true,
				side: DoubleSide,
			});

			const agua = new MeshPhongMaterial({
				color: "white",
				flatShading: true,
				side: DoubleSide,
			});

			const watertexture = new THREE.TextureLoader().load( 'textures/water2.jpg' );
// immediately use the texture for material creation
const watermaterial = new THREE.MeshBasicMaterial( { map: watertexture } );

			
			const loadingManager = new THREE.LoadingManager();

			loadingManager.onStart = (url, item, total) => {
				console.log("loading started");
				//create alert to show loading started
				alert("carregando");				
			};

			loadingManager.onProgress = (url, loaded, total) => {
				console.log("loading finished");
			};

			loadingManager.onLoad = () => {
				console.log("loading finished");
				alert("Carregou! Use o scroll do mouse para visualizar a casa");	
			};

			loadingManager.onError = (url) => {
				console.error("loading error");
			};

			const ifcLoader = new IFCLoader(loadingManager);
			ifcLoader.ifcManager.setWasmPath("jsm/loaders/ifc/");

			//add loaded shader material
			let slidersAclive = document.getElementById("container");
			let slidersPlano = document.getElementById("containerPlano");
			let slidersDeclive = document.getElementById("containerDeclive");
			let sliderA = document.getElementById("inA");
			let sliderB = document.getElementById("inB");
			let sliderC = document.getElementById("inC");
			let sliderD = document.getElementById("inD");
			let sliderE = document.getElementById("inE");
			let sliderF = document.getElementById("inF"); //plano 
			let sliderG = document.getElementById("inG");
			let sliderH = document.getElementById("inH");
			let sliderI = document.getElementById("inI");//plano 
			let sliderJ = document.getElementById("inJ"); //declive
			let sliderK = document.getElementById("inK");
			let sliderL = document.getElementById("inL");
			let sliderM = document.getElementById("inM"); //declive
			let sliderN = document.getElementById("inN"); //declive
			let sliderO = document.getElementById("inO");
			

			//add event listener on scroll screen

			let modelo = document.getElementById("modelo");
			let inclinacao = document.getElementById("inclinacao");
			let cube = document.getElementById("cube");
			let cube2 = document.getElementById("cube2");
			let cube3 = document.getElementById("cube3");
			console.log(cube)

			setSizeS();

			const params = {
				color: '#ffffff',
				scale: 4,
				flowX: 1,
				flowY: 1
			};

			const pgeometry = new THREE.BoxGeometry(3, 1.5, 5);
				const piscina = new THREE.Mesh(pgeometry, watermaterial);
				piscina.position.set(1.5, -0.5, fundodaCasa - 3.2);
				water = new Water( pgeometry, {
					color: params.color,
					scale: params.scale,
					flowDirection: new THREE.Vector2( params.flowX, params.flowY ),
					textureWidth: 100,
					textureHeight: 100
				} );

				water.position.set(1.5, -0.4, fundodaCasa - 3.2)
				// water.position.y = 1;
				// water.rotation.x = Math.PI * - 0.5;
				


			cube.onclick = function () {
				

				//add if statement to check if piscina is childelement of scene
				if (scene.getObjectByName("piscina") === undefined) {
					// scene.add( water );
					scene.add(piscina);
					piscina.name = "piscina";
					cube.innerHTML = "Remover Piscina";
				} else {
					scene.remove(scene.getObjectByName("piscina"));
					cube.innerHTML = "Adicionar Piscina";
				}
				render();
			};

			cube2.onclick = function () {
				
				//add if statement to check if piscina is childelement of scene
				if (scene.getObjectByName("piscina") === undefined) {
					scene.add(piscina);
					piscina.name = "piscina";
					cube2.innerHTML = "Remover Piscina";
				} else {
					scene.remove(scene.getObjectByName("piscina"));
					cube2.innerHTML = "Adicionar Piscina";
				}
				render();
			};

			cube3.onclick = function () {
				console.log('clicou')
				

				//add if statement to check if piscina is childelement of scene
				if (scene.getObjectByName("piscina") === undefined) {
					scene.add(piscina);
					piscina.name = "piscina";
					cube3.innerHTML = "Remover Piscina";
				} else {
					scene.remove(scene.getObjectByName("piscina"));
					cube3.innerHTML = "Adicionar Piscina";
				}
				render();
			};

			const edicula = document.getElementById("edicula");
				edicula.addEventListener("click", function () {
					if (scene.getObjectByName("ediculaMesh") === undefined){
						if(inclinacao.value == 'Aclive'){
							ediculaGeo = new THREE.BoxGeometry((larguraFrente + larguraMorro + recuoLateral), 3, 3);
						}
						else{
							ediculaGeo = new THREE.BoxGeometry((larguraCasaPlana + recuoLateral), 3, 3);
						}
						
						ediculaMesh = new THREE.Mesh(ediculaGeo, material2);
					ediculaMesh.position.set(5, 0, fundodaCasa - 3.2);
					ediculaMesh.rotation.set(0, 0, 0);
					scene.add(ediculaMesh);
					ediculaMesh.name = "ediculaMesh";
					edicula.innerHTML =  "Remover edícula";
					}else{
						edicula.innerHTML = "Adicionar edícula" ;
						scene.remove(ediculaMesh);
					}
					render();
				});

			modelo.onchange = function() {
				addModelo();
			}

			 function addModelo () {
				if (inclinacao.value == "Aclive") {
				scene.remove(CASA);
				if (modelo.value == "3S") {
					ifcLoader.load("models/ifc/3S.ifc", function (object) {
						CASA = object;
						scene.add(CASA);
						

					});
				}
				if (modelo.value == "3S+Q") {
					ifcLoader.load("models/ifc/3S+Q.ifc", function (object) {
						CASA = object;
						scene.add(CASA);
					});
				}
				if (modelo.value == "4S") {
					ifcLoader.load("models/ifc/4S.ifc", function (object) {
						CASA = object;
						scene.add(CASA);
					});
				}
				if (modelo.value == "4S+Q") {
					ifcLoader.load("models/ifc/4S+Q.ifc", function (object) {
						CASA = object;
						scene.add(CASA);
					});
				}				
				render();
			}
			else {
				scene.remove(CASA);
				if (modelo.value == "3S") {
					ifcLoader.load("models/ifc/3SPlana.ifc", function (object) {
						CASA = object;
						CASA.position.set(0,0.02,0);
						CASA.rotation.set(0,3.32,0);
				
						scene.add(CASA);
					});
				}
				if (modelo.value == "3S+Q") {
					ifcLoader.load("models/ifc/3S+QPlana.ifc", function (object) {
						CASA = object;
						CASA.position.set(0,0.02,0);
						CASA.rotation.set(0,3.32,0);
						scene.add(CASA);
					});
				}
				if (modelo.value == "4S") {
					ifcLoader.load("models/ifc/4SPlana.ifc", function (object) {
						CASA = object;
					CASA.position.set(0,0.02,0);
						CASA.rotation.set(0,3.32,0);
						scene.add(CASA);
					});
				}
				if (modelo.value == "4S+Q") {
					ifcLoader.load("models/ifc/4S+QPlana.ifc", function (object) {
						CASA = object;
					CASA.position.set(0,0.02,0);
						CASA.rotation.set(0,3.32,0);
						scene.add(CASA);
					});
				}				


				render();
			}
			
			
			
		}

			inclinacao.onchange = function () {
				scene.remove(CASA)
				if (scene.getObjectByName("piscina") != undefined) {scene.remove(piscina)};
				for (let i = 0; i < sizeS.length; i++) {
					scene.remove(meshs[i]);
					scene.remove(mesh);
				}
				sizeS.length = 0;
				console.log(inclinacao.value)
				
				if (inclinacao.value == "Declive") {
					setSizeSDeclive();
					slidersAclive.style.display = "none";
					slidersDeclive.style.display = "flex";
					slidersPlano.style.display = "none";
				} 
				if (inclinacao.value == "Plano") {
					setSizeSPlano();
					slidersAclive.style.display = "none";
					slidersDeclive.style.display = "none";
					slidersPlano.style.display = "flex";

				}
				if (inclinacao.value== "Aclive") {
					setSizeS();
					slidersAclive.style.display = "flex";
					slidersDeclive.style.display = "none";
					slidersPlano.style.display = "none";
				}

				for (let i = 0; i < sizeS.length; i++) {
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				addModelo();
				render();
			};

			
			sliderA.oninput = function () {
				for (let i = 0; i < sizeS.length; i++) {
					scene.remove(meshs[i]);
					scene.remove(mesh);
					desnivelTerreno = this.value - parseFloat(alturaCasa);
					setSizeS();
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				render();
			};
			sliderB.oninput = function () {
				for (let i = 0; i < sizeS.length; i++) {
					scene.remove(meshs[i]);
					scene.remove(mesh);
					profundidadeTerreno = this.value - parseFloat(recuoFrontal);
					fundodaCasa = profundidadeTerreno - 2;
					setSizeS();
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				render();
				custos();
			};
			sliderC.oninput = function () {
				for (let i = 0; i < sizeS.length; i++) {
					scene.remove(meshs[i]);
					scene.remove(mesh);
					alturaCasa = this.value;
					setSizeS();
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				render();
			};
			sliderD.oninput = function () {
				for (let i = 0; i < sizeS.length; i++) {
					scene.remove(meshs[i]);
					console.log(
						profundidadeTerreno +
							recuoFrontal +
							recuoFrontal -
							parseFloat(this.value)
					);
					document.getElementById("inB").value =
						profundidadeTerreno +
						recuoFrontal +
						recuoFrontal -
						parseFloat(this.value);

					document.getElementById("outB").value =
						profundidadeTerreno +
						recuoFrontal +
						recuoFrontal -
						parseFloat(this.value);

					recuoFrontal = parseFloat(this.value);
					setSizeS();
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				render();
			};
			sliderE.oninput = function () {
				for (let i = 0; i < sizeS.length; i++) {
					scene.remove(meshs[i]);
					recuoLateral = parseFloat(this.value);

					setSizeS();
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				render();
			};
			sliderF.oninput = function () {				
				for (let i = 0; i < sizeS.length; i++) {
					scene.remove(meshs[i]);
					larguraCasaPlana = parseFloat(this.value) - parseFloat(recuoLateral) - parseFloat(recuoLateral);
					setSizeSPlano();
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				render();
			};
			sliderG.oninput = function () {
				for (let i = 0; i < sizeS.length; i++) {
					scene.remove(meshs[i]);
					
					profundidadeTerreno = 37 - parseFloat(this.value);
					
					recuoFrontal = parseFloat(this.value)
					
					// document.getElementById("inG").value =
					// 	profundidadeTerreno +
					// 	recuoFrontal +
					// 	recuoFrontal -
					// 	parseFloat(this.value);

					// document.getElementById("outG").value =
					// 	profundidadeTerreno +
					// 	recuoFrontal +
					// 	recuoFrontal -
					// 	parseFloat(this.value);
					setSizeSPlano();
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				render();
			}
			sliderH.oninput = function () {
				for (let i = 0; i < sizeS.length; i++) {
				scene.remove(meshs[i]);
					recuoLateral = parseFloat(this.value)
					document.getElementById("inF").value = 11 + parseFloat(this.value) + parseFloat(this.value);
					document.getElementById("outF").value = (11 + parseFloat(this.value) + parseFloat(this.value)).toFixed(1);
					console.log(larguraCasaPlana)
					setSizeSPlano();
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				render();
			}
			sliderI.oninput = function () {
				for (let i = 0; i < sizeS.length; i++) {
				scene.remove(meshs[i]);
					profundidadeTerreno = parseFloat(this.value)
					setSizeSPlano();
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				render();
			}
			sliderJ.oninput = function () {
				for (let i = 0; i < sizeS.length; i++) {
				scene.remove(meshs[i]);
					desnivelTerreno = parseFloat(this.value)
					setSizeSDeclive();
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				render();
			}
			sliderK.oninput = function () {
				for (let i = 0; i < sizeS.length; i++) {
				scene.remove(meshs[i]);
				alturaCasaDeclive = parseFloat(this.value)
					setSizeSDeclive();
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				render();
			}
			sliderL.oninput = function () {
				for (let i = 0; i < sizeS.length; i++) {
					scene.remove(meshs[i]);
					console.log(
						profundidadeTerreno +
							recuoFrontal +
							recuoFrontal -
							parseFloat(this.value)
					);
					document.getElementById("inN").value =
						profundidadeTerreno +
						recuoFrontal +
						recuoFrontal -
						parseFloat(this.value);

					document.getElementById("outN").value =
						profundidadeTerreno +
						recuoFrontal +
						recuoFrontal -
						parseFloat(this.value);

					recuoFrontal = parseFloat(this.value);
					setSizeSDeclive();
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				render();
			}
			sliderM.oninput = function () {
				for (let i = 0; i < sizeS.length; i++) {
				scene.remove(meshs[i]);
					recuoLateral = parseFloat(this.value)
					setSizeSDeclive();
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				render();
			}
			sliderN.oninput = function () {
				for (let i = 0; i < sizeS.length; i++) {
				scene.remove(meshs[i]);
					profundidadeTerreno = parseFloat(this.value) - recuoFrontal
					setSizeSDeclive();
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				render();
			}
			sliderO.oninput = function () {
				for (let i = 0; i < sizeS.length; i++) {
				scene.remove(meshs[i]);
					profundidadeQuintal = parseFloat(this.value)
					setSizeSDeclive();
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
				}
				render();
			}

			init();
			render();

			function init() {
				scene = new Scene();
				//				scene.background = new Color(0x000000);
				// const near = 0;
				// const far = 70;
				// scene.fog = new THREE.Fog(0xffffff, near, far);

				camera = new PerspectiveCamera(
					75,
					window.innerWidth / window.innerHeight,
					0.1,
					500
				);
				camera.position.z = -10.815689572206287;
				camera.position.y = -0.953789666614475;
				camera.position.x = 4.537079972316929;
				camera.rotation.x = -3.12;
				camera.rotation.y = 0.0417;
				camera.rotation.z = 3.141;

				const lights = [];
				lights[0] = new PointLight(0xffffff, 0.4, 0);
				lights[1] = new PointLight(0xffffff, 0.4, 0);
				lights[2] = new PointLight(0xffffff, 0, 0);
				lights[3] = new THREE.DirectionalLight(0xdfebff, 1);
				lights[0].position.set(0, 200, 0);
				lights[1].position.set(100, 200, 100);
				lights[2].position.set(-100, -200, -100);

				scene.add(lights[0]);
				scene.add(lights[1]);
				scene.add(lights[2]);
				//scene.add(lights[3]);

				lights[4] = new THREE.AmbientLight(0x404040); // soft white light
				scene.add(lights[4]);
				lights[5] = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.2);
				scene.add(lights[5]);
				lights[6] = new THREE.SpotLight(0xffffff, 1, 0);
				lights[6].position.set(50, 500, 10);
				//scene.add(lights[6]);
				lights[6].castShadow = true;
				lights[6].shadow.mapSize.width = 512; // default
				lights[6].shadow.mapSize.height = 512; // default
				lights[6].shadow.camera.near = 0.5; // default
				lights[6].shadow.camera.far = 500; // default
				lights[6].shadow.bias = -0.005;

				// lights[6].shadow.focus = 1;
				//ADD HELPER LIGHTS[6]
				const helper = new THREE.SpotLightHelper(lights[6]);
				//add target object to the light
				lights[6].target = new THREE.Object3D();
				//scene.add(helper);

				//Setup IFC Loader
				// const ifcLoader = new IFCLoader();
				// ifcLoader.ifcManager.setWasmPath("jsm/loaders/ifc/");
				// console.log(modelo.value);

				ifcLoader.load("models/ifc/3S.ifc", function (model) {
					model.position.set(modelA, modelB, modelC);
					model.rotation.set(0, 0, 0);
					CASA = model.mesh;
					scene.add(CASA);
					CASA.receiveShadow = true;
					CASA.castShadow = true;
					//disable clipping planes
					CASA.material.clippingPlanes = [localPlane];
					CASA.material.clipIntersection = true;

					render();
				});

				const localPlane = new THREE.Plane(
					new THREE.Vector3(0, -1, 0),
					parseFloat(alturaCasa) - 1
				);

				//Renderer
				// renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
				// renderer.setClearColor(0x000000, 0); // the default
				// renderer.shadowMap.enabled = true;
				// renderer.shadowMap.type = THREE.PCFSoftShadowMap;

				// renderer.setSize(window.innerWidth, window.innerHeight);
				// renderer.setPixelRatio(window.devicePixelRatio);
				// document.body.appendChild(renderer.domElement);

				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				// renderer.setClearColor(scene.fog(0x000000, 0.5)); // precisa passar a cor como variavel

				document.body.appendChild(renderer.domElement);

				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.shadowMap.enabled = true;
				//create a button to change the clipping plane
				const button = document.getElementById("telhado");
				button.addEventListener("click", function () {
					if( button.innerHTML == "Retirar telhado"){
					button.innerHTML = "Mostrar telhado" ;
					renderer.clippingPlanes = [localPlane];
					console.log('clicou')
					}else{
						button.innerHTML = "Retirar telhado" ;
						renderer.clippingPlanes = [];
					}
					render();
				});


				
				//Controls
				const controls = new OrbitControls(camera, renderer.domElement);
				controls.addEventListener("change", render);
				// controls.addEventListener("change", function () {
				// 	console.log(camera.position);
				// 	console.log(camera.rotation);
				// });

				window.addEventListener("resize", onWindowResize);

				for (let i = 0; i < sizeS.length; i++) {
					geometries[i] = new BufferGeometry();
					verticesS[i] = new Float32Array(sizeS[i]);
					geometries[i].setAttribute(
						"position",
						new BufferAttribute(verticesS[i], 3)
					);
					meshs[i] = new Mesh(geometries[i], material);
					scene.add(meshs[i]);
					meshs[i].receiveShadow = true;
					meshs[i].castShadow = true;
				}

				for (let j = 0; j < sizeS2.length; j++) {
					geometries2[j] = new BufferGeometry();
					verticesS2[j] = new Float32Array(sizeS2[j]);
					geometries2[j].setAttribute(
						"position",
						new BufferAttribute(verticesS2[j], 3)
					);
					meshs2[j] = new Mesh(geometries2[j], material2);
					scene.add(meshs2[j]);
				}


				// const plano2 = new THREE.Mesh(new THREE.PlaneGeometry (2,2,512,512), 
				// new THREE.MeshPhongMaterial(
				// 	{
						

				// 		// map: gColor,
				// normalMap: gNormal,
				// normalScale: new THREE.Vector2(1,1),
				// roughnessMap: gRough,
				// // aoMap: gAmbient,
				// bumpMap: gDisp,
				// bumpScale: 2,
				// displacementMap: gDisp,
				// // displacementScale: 0.1,
				// // roughness: 0.5,
				// color: "#39542e",
				// flatShading: true,
				// side: DoubleSide,
				// 	}
				// )
				// );
				// plano2.position.set(0,10,0);
				// scene.add(plano2);

				// let shader = THREE.ShaderChunk.shadowmap_pars_fragment;

				// shader = shader.replace(
				// 	"#ifdef USE_SHADOWMAP",
				// 	"#ifdef USE_SHADOWMAP" + document.getElementById("PCSS").textContent
				// );

				// shader = shader.replace(
				// 	"#if defined( SHADOWMAP_TYPE_PCF )",
				// 	document.getElementById("PCSSGetShadow").textContent +
				// 		"#if defined( SHADOWMAP_TYPE_PCF )"
				// );

				// THREE.ShaderChunk.shadowmap_pars_fragment = shader;

				render();
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);

				render();
			}

			function render() {
				// setTimeout(function () {
				// 	requestAnimationFrame(render);
				// 	renderer.render(scene, camera);
				// }, 5000 / 60);
				renderer.render(scene, camera);
			}

			function animate() {
				requestAnimationFrame(animate);
				render();
			}

			csv({
				output: "csv",
			});
			const url =
				"https://docs.google.com/spreadsheets/d/1lTZpSuPc0hgY5xglxDV5K92Bzd97ta6OiBWuW79mkJk/export?format=csv";

			let dados;

			function custos() {
				fetch(url)
					.then((result) => result.text())
					.then(function (csvtext) {
						return csv().fromString(csvtext);
					})
					.then(function (result) {
						dados = result.map((item) => {
							return {
								P: item.P,
								M: item.M,
								G: item.G,
								CHASSIf: item.CHASSIf,
								ACABAMENTOf: item.ACABAMENTOf,
								CHASSIc: item.CHASSIc,
								ACABAMENTOc: item.ACABAMENTOc,
							};
						});
					})

					.then(function calculateCost(e) {
						const muro = profundidadeTerreno;
						const cost = muro * dados[7].CHASSIc;

						const costMargem = cost * dados[15].CHASSIc;
						costMargem.toFixed(0);

						const total = document.querySelector("main");
						total.innerText =
							"R$" +
							new Intl.NumberFormat("pt-BR", { currency: "BRL" }).format(
								costMargem
							);
					});
			}
			custos();
		</script>
	</body>
</html>
